# Отчёт по лабораторной работе 10
## Графы

**Дата:** 18.12.2025
**Семестр:** 3 курс 1 полугодие - 5 семестр
**Группа:** ПИЖ-б-о-23-2-1
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Чекалин Егор Юрьевич

## Характеристики ПК для тестирования
Модель устройства: ASUS TUF Gaming A15
CPU: AMD Ryzen 7 7735HS 3.2 GHz
GPU: Nvidia GeForce RTX 4060 Mobile
RAM: 16 GB
SSD: 100 GB

## Цель работы

Изучить основные понятия теории графов и алгоритмы работы с ними. Освоить
представления графов в памяти и основные алгоритмы обхода. Получить практические навыки
реализации алгоритмов на графах и анализа их сложности.

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Реализовать различные представления графов (матрица смежности, список смежности)
- [x] Задача 2: Реализовать алгоритмы обхода графов (BFS, DFS)
- [x] Задача 3: Реализовать алгоритмы поиска кратчайших путей и компонент связности
- [x] Задача 4: Провести сравнительный анализ эффективности разных представлений графов
- [x] Задача 5: Решить практические задачи на графах

## Результаты выполнения

### Пример работы программы

```bash
======================================================================
ДЕМОНСТРАЦИЯ АЛГОРИТМОВ НА ГРАФАХ
======================================================================

======================================================================
ЗАДАЧА 1: Поиск пути в лабиринте
======================================================================

Исходный лабиринт:
S #  
# # #
     
 ### 
    E

Найден маршрут длиной 9:
Координаты пути: [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (2, 4), (3, 4), (4, 4)]

Лабиринт с решением:
S.#  
#.# #
 ....
 ###.
    E

======================================================================
ЗАДАЧА 2: Анализ сетевой связности
======================================================================
==================================================
ОТЧЕТ О СОСТОЯНИИ СЕТИ
==================================================
Узлов всего: 9
Соединений всего: 6
Сеть единая: Нет
Количество компонент: 4
Изолированные узлы: [8]
Критические узлы: [0, 1, 2, 3, 4, 5, 6, 7]

Компоненты связности:
  Компонента 1: [0, 1, 2]
  Компонента 2: [3, 4, 5]
  Компонента 3: [6, 7]
  Компонента 4: [8]

======================================================================
ЗАДАЧА 3: Планирование задач
======================================================================

Расписание выполнимо: Да
Порядок выполнения: A → B → C → D → E → F

Общая длительность: 11.0
Критический путь: F
```

### Анализ производительности

#### Сравнение использования памяти
Для плотных графов (50% рёбер):
| Вершины | Матрица (KB) | Список (KB) | Экономия |
|---------|--------------|-------------|----------|
| 10      | 2.91         | 2.62        | 10.2%    |
| 50      | 68.82        | 49.60       | 27.9%    |
| 100     | 274.34       | 189.34      | 31.0%    |
| 200     | 1095.37      | 734.25      | 33.0%    |
| 500     | 6840.05      | 4508.26     | 34.1%    |

Для разреженных графов (линейное число рёбер):
| Вершины | Матрица (KB) | Список (KB) | Экономия |
|---------|--------------|-------------|----------|
| 10      | 2.91         | 2.48        | 15.0%    |
| 50      | 68.82        | 13.25       | 80.8%    |
| 100     | 274.34       | 27.42       | 90.0%    |
| 200     | 1095.37      | 55.84       | 94.9%    |
| 500     | 6840.05      | 135.01      | 98.0%    |

#### Производительность операций
**Проверка наличия ребра (has_edge()):**
- Для плотных графов матрица быстрее в 1.4-7.9 раз
- Для разреженных графов матрица быстрее в 1.2-1.3 раз

**Сравнение алгоритмов обхода:**
| Вершины | BFS (мкс) | DFS Итеративный (мкс) |
|---------|-----------|----------------------|
| 50      | 93.93     | 79.35                |
| 100     | 99.51     | 120.09               |
| 200     | 192.35    | 222.50               |
| 300     | 296.72    | 343.92               |

**Сравнение поиска путей:**
| Вершины | BFS (мкс) | Dijkstra (мкс) | Коэффициент |
|---------|-----------|----------------|-------------|
| 50      | 47.43     | 279.51         | 5.89x       |
| 100     | 90.70     | 418.24         | 4.61x       |
| 200     | 169.27    | 843.47         | 4.98x       |
| 300     | 244.23    | 1292.84        | 5.29x       |

**Масштабируемость алгоритмов:**
| Вершины | Рёбра | BFS (мкс) | DFS (мкс) |
|---------|-------|-----------|-----------|
| 100     | 118   | 105.43    | 130.75    |
| 200     | 238   | 167.88    | 226.35    |
| 300     | 358   | 268.97    | 378.69    |
| 400     | 478   | 368.00    | 481.87    |

### Визуализации
В ходе работы были созданы следующие графики:

![Сравнение сложности операций](complexity_comparison.png)
*Рисунок 1: Сравнение сложности различных операций для разных представлений графов*

![Примеры графов](graph_examples.png)
*Рисунок 2: Примеры графов для различных алгоритмов*

![Сравнение использования памяти](memory_comparison.png)
*Рисунок 3: Сравнение потребления памяти матрицей смежности и списком смежности*

![Масштабируемость алгоритмов](scalability.png)
*Рисунок 4: Масштабируемость алгоритмов BFS, DFS и Dijkstra*

### Тестирование
```bash
...................................
----------------------------------------------------------------------
Ran 35 tests in 0.003s

OK
```

Все тесты пройдены успешно, что подтверждает корректность реализации алгоритмов.

## Структура проекта
```
.
├── analysis.py              # Анализ производительности
├── complexity_comparison.png
├── graph_examples.png
├── main.py                  # Основная программа с практическими задачами
├── memory_comparison.png
├── modules/                 # Модули с реализацией алгоритмов
│   ├── graph_representation.py
│   ├── graph_traversal.py
│   └── shortest_path.py
├── scalability.png
├── tests.py                 # Юнит-тесты
└── visualisation.py         # Визуализация результатов
```

## Выводы
1. **Матрица смежности** оптимальна для плотных графов и операций проверки наличия ребра, однако потребляет значительно больше памяти для разреженных графов. **Список смежности** экономичнее по памяти для разреженных графов и эффективнее для обхода соседей, но медленнее при проверке наличия конкретного ребра.

2. **BFS** демонстрирует лучшую производительность для поиска кратчайших путей в невзвешенных графах, в то время как **DFS** более эффективен для задач, требующих глубокого исследования структуры графа (поиск компонент связности, проверка на ацикличность).

3. **Алгоритм Дейкстры** является наиболее ресурсоемким из рассмотренных алгоритмов (в 4-6 раз медленнее BFS), что обусловлено его сложностью O((V+E)logV) и необходимостью работы с приоритетной очередью. Однако он незаменим для поиска кратчайших путей во взвешенных графах с неотрицательными весами.

## Ответы на контрольные вопросы
1. **В чем разница между представлением графа в виде матрицы смежности и списка смежности?**  
Матрица смежности хранит информацию о всех возможных рёбрах в виде квадратной матрицы V×V, что обеспечивает быстрый доступ O(1) к проверке наличия ребра, но требует O(V²) памяти. Список смежности хранит для каждой вершины только список её соседей, что экономит память до O(V+E) для разреженных графов, но проверка наличия ребра занимает O(degree(v)). Матрица эффективна для плотных графов, список — для разреженных.

2. **Опишите алгоритм поиска в ширину (BFS). Для решения каких задач он применяется?**  
BFS начинает с начальной вершины, посещает всех её соседей, затем соседей соседей и так далее, используя очередь. Алгоритм гарантированно находит кратчайший путь в невзвешенном графе. Применяется для поиска кратчайшего пути, проверки связности графа, поиска компонент связности, нахождения расстояний между вершинами, решения задач вроде лабиринтов.

3. **Чем поиск в глубину (DFS) отличается от BFS? Какие дополнительные задачи можно решить с помощью DFS?**  
DFS исследует граф, уходя как можно глубже по одной ветке, прежде чем возвращаться (использует стек), тогда как BFS исследует граф "слоями". DFS применяется для топологической сортировки, поиска компонент сильной связности, проверки графа на ацикличность, поиска мостов и точек сочленения, решения задач с возвратом (backtracking).

4. **Как алгоритм Дейкстры находит кратчайшие пути во взвешенном графе? Почему он не работает с отрицательными весами ребер?**  
Алгоритм Дейкстры использует жадную стратегию: на каждом шаге выбирает вершину с минимальным известным расстоянием, обновляет расстояния до её соседей. Он не работает с отрицательными весами, потому что предположение о том, что кратчайший путь к вершине найден, когда она извлекается из очереди, перестаёт быть верным — может существовать путь через отрицательное ребро, уменьшающий расстояние.

5. **Что такое топологическая сортировка и для каких графов она применима? Приведите пример задачи, где она используется.**  
Топологическая сортировка — это линейное упорядочение вершин ориентированного графа, при котором для любого ребра (u→v) вершина u стоит перед v. Применима только для ациклических ориентированных графов (DAG). Примеры задач: определение порядка выполнения задач с зависимостями, планирование учебных курсов с пререквизитами, компиляция исходного кода с разрешением зависимостей между модулями, определение последовательности операций в проекте.